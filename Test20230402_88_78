package Test;

import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

/**
 * Map接口：
 * 1、键值对存储一组对象
 * 2、Key不能重复（唯一），Value可以重复
 * 3、具体的实现类：HashMap,TreeMap,Hashtable,LinkedHashMap
 * 4、hashMap与hashtable的区别？
 * 
 * 5、如何选择使用哪个？
 * 
 * 6、数据结构：数组、链表、二叉树（红黑树）、哈希表（数组+链表）、栈、队列
 * @author yangzixi
 *
 */
public class Test78_Map {

	/**
	 * 基于二叉树的红黑树实现
	 */
	private static void treeMap() {
		Map<String,String> map = new TreeMap<>();
//		map.put("one","Lily");
//		map.put("two","Tom");
//		map.put("three","Bin");
//		map.forEach((key,value)->System.out.println(key+"->"+value));
		
		Map<Test78_dog,String> dogs = new TreeMap<>();
		dogs.put(new Test78_dog(1,"2ha",3),"dog1");
		dogs.put(new Test78_dog(2,"wangwang",3),"dog2");
		dogs.put(new Test78_dog(3,"4ha",3),"dog3");
		dogs.forEach((key,value)->System.out.println(key+"->"+value));

	}
	/**
	 * LinkedHashMap是HashMap的子类，由于HashMap不能保证顺序恒久不变，此类使用一个双重链表来维护
	 * 元素添加的顺序。
	 */
	private static void LinkedHashMap() {
		Map<String,String> table = new LinkedHashMap<>();
		table.put("one","Lily");
		table.put("two","Tom");
		table.put("three","Bin");
		table.forEach((key,value)->System.out.println(key+"->"+value));
	}
	/**
	 * JDK1.0
	 * 基于哈希表实现（数组+链表）
	 * 默认数组大小为11，加载因子0.75
	 * 扩充方式：原数组大小<<1(*2)+1
	 * 线程安全的，用在多线程访问时
	 */
	private static void hashtable(){
		Map<String,String> table = new Hashtable<>();
		table.put("one","Lily");
		table.put("two","Tom");
		table.put("three","Bin");
		
		table.forEach((key,value)->System.out.println(key+"->"+value));
	}
	/**
	 * HashMap的实现原理：
	 * 1、基于哈希表（数组加链表+二叉树（红黑树））1.8JDK
	 * 2、默认加载因子为0.75（75%），默认数组大小是16
	 * 3、把对象存储到哈希表中，如何存储的？
	 * (1)把Key对象通过hash()方法计算hash值，然后用这个hash值对数组长度取余（默认是16），来决定该Key对象
	 * 在数组中存储的位置，当这个位置有多个对象时，以链表结构存储，JDK1.8后，当链表长度大于8时，链表将转换为红黑树结构存储。
	 * 这样的目的，是为了取值更快，存储的数据量越大，性能的表现越明显
	 * 4、扩充原理：当数组的容量超过了75%，那么表示该数组需要扩充，如何扩充？
	 * 扩充的算法是：当前数组容量<<1(相当于是乘2)，扩大1倍，扩充次数过多，会影响性能，每次扩充表示哈希表重新
	 * 散列（重新计算每个对象的存储位置），我们在开发中尽量要减少扩充次数带来的性能问题
	 * 5、线程不安全，适合在单线程中使用
	 */
	private static void hashMap() {
		Map<Integer,String> map = new HashMap<>();
		map.put(1, "Demon");
		map.put(2, "yang");
		map.put(3, "Vince");
		map.put(4, "List");
		map.put(5, "Bin");
		
		System.out.println("size="+map.size());
		System.out.println("--------");
		//从map中取值
		System.out.println(map.get(1));//通过key取value
		System.out.println("--------");
		
		//map的遍历1(遍历键值Entry)
		Set<Entry<Integer,String>> entrySet = map.entrySet();
		for(Entry e:entrySet) {
			System.out.println(e.getKey()+"->"+e.getValue());
			
		}
		System.out.println("--------");
		
		//map的遍历2（遍历键）
		Set<Integer> keys = map.keySet();
		for(Integer i:keys) {
			String value = map.get(i);
			System.out.println(i+"->"+value);
			
		}
		System.out.println("--------");
		
		//map的遍历3(遍历值)
		Collection<String> values = map.values();
		for(String s:values) {
			System.out.println(s);
		}
		System.out.println("--------");
		
		//map的遍历4
		map.forEach((key,value)->System.out.println(key+"->"+value));
		
		System.out.println("--------");
		System.out.println(map.containsValue("Demon"));
		System.out.println(map.containsKey(7));
		System.out.println("--------");
		
		//hash
		Integer key = 1234;
		System.out.println(1234%16);
	}
	public static void main(String[] args) {
//		hashMap();
//		hashtable();
		treeMap();
	}

}
----------------------------------------------------------
package Test;

public class Test78_dog implements Comparable<Test78_dog>{
	private int id;
	private String name;
	private int age;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Test78_dog [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
	public Test78_dog(int id, String name, int age) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
	}
	public Test78_dog() {
		super();
		// TODO Auto-generated constructor stub
	}
	@Override
	public int compareTo(Test78_dog o) {
		return this.id-o.id;
	}

}

